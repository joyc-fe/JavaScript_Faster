### 第三章 DOM编程

#### 1. 浏览器中的DOM

文档对象模型(DOM)是一个独立于语言的，用以操作XML和HTML文档的程序接口(API)。在浏览器中的接口是用JavaScript实现的，浏览器通常会把DOM和JavaScript独立实现，这样就可以允许其他技术比如VBScript能共享DOM。

DOM和JavaScript是两个独立的部分，只要通过接口连接，就会产生性能消耗，并且连接次数越多，消耗越大。

#### 2. DOM访问与修改

访问DOM元素会产生性能消耗，而修改DOM元素的代价更大--因为会导致浏览器重新计算页面的几何变化并重新渲染。

innerHTML与DOM方法，操作更新一大段HTML时，非标准但支持良好的innerHTML方法在绝大多数浏览器中要快于DOM方法，而对大多数日常操作来说没有明显的区别。

HTML集合是包含了DOM节点引用的类数组对象，可以通过以下方法或属性获取：

- document.getElementsByName()
- document.getElementsByClassName()
- document.getElementsByTagName()
- document.images
- document.links
- document.forms

HTML集合并不是真正的数组，因为没有push和slice等方法，但是有length属性并且可以通过索引获取指定DOM节点。HTML集合与文档保持连接，当文档改变时，HTML集合也会自动更新(假定实时态)，所以每次获取HTML集合信息(比如获取length属性)时都会重新执行查询过程，导致性能低下。与真正的数组相比，HTML集合的遍历速度非常低。

优化方法：

- 涉及到循环时，尽量使用局部变量，避免使用document重复查询元素
- 在循环之前，先将要操作的HTML集合缓存下来(缓存集合，每次操作都要根据索引从HTML集合中获取要操作的DOM)
- 循环之前，将要操作的DOM缓存下来(缓存DOM，性能最好，不用每次根据索引获取指定的DOM元素)

##### 遍历DOM

当获取某个元素周围的元素时候，可以使用childNodes或nextSibing，在IE6和IE7中，使用nextSibing要比childNodes快。

childNodes并不区分元素节点和属性节点，而在大部分现代浏览器中，childNodes只返回元素节点。

选择器API，根据CSS选择器查询特定元素，比如document.querySelector()和querySelectorAll()，这两个方法都是DOM节点的反复，因此支持子查询。返回NodeList(包含匹配节点的类数组对象)，NodeList对象是一个静态列表，不会对应实时的文档结构。

HTML集合 | NodeList
---|---
实时对应文档结构 | 不实时对应文档结构

#### 3. 重绘与重排

浏览器下载完页面所有的组件-HTML标记、JavaScript、CSS、图片之后会解析并生成两个内部数据结构：

- DOM树，表示页面结构
- 渲染树，表示DOM节点如何显示

DOM树中的每一个需要显示的节点在渲染树中至少存在一个对应的节点。当DOM树和渲染树构建完成之后，浏览器就开始绘制页面元素。

如果DOM的变化影响了元素的几何属性，则浏览器就重新计算元素的几何属性，其他元素的几何属性和位置也会受影响，会导致原先渲染树部分失效，所以浏览器必须对页面进行重排(reflow)，完成重排之后，浏览器会重新绘制受影响的部分，这个过程称为重绘(repaint)。并不是所有的DOM变化都会引起重排。比如元素的背景色的改变并不会影响几何属性，此时只需要重绘即可。也就是说重绘不一定重排，而重排一定会重绘，无论是重排还是重绘，其代价都很高。

引起重排的情况有以下几种：

- 添加或删除可见的DOM元素
- 元素位置改变
- 元素尺寸改变(margin,padding,border,width,height,etc.)
- 内容改变
- 页面渲染器初始化
- 浏览器窗口尺寸变化
- 其他，比如滚动条的出现会触发整个页面的重排

在大多数浏览器中，都会通过队列化修改并批量执行来优化重排过程，但是这个过程会被某些操作被强制刷新并立刻执行。比如offsetTop/offsetLeft等属性需要返回最新的布局信息，因此浏览器会强制渲染队列中的操作，并触发重排。因此在修改样式的过程中要避免使用这些属性。

优化原则：最小化重绘和重排

##### 合并操作
```
el.style.borderLeft = "1px";
el.style.borderRight = "2px";
el.style.padding = "5px";
```
可以优化为：

```
el.style.cssText = "border-left:1px;border-right:2px;padding:5px;"
```

##### 批量操作

如果要对DOM元素进行一系列操作，则可以通过以下步骤来减少重绘和重排：

- 使元素脱离文档流
- 对元素执行操作
- 把元素带回文档流

这个过程会触发两次重排：脱离文档流和带回文档流，相比操作过程中可能产生的多次重排，这已经很好了。

使DOM脱离文档流的方法：

- 隐藏元素
- 使用文档片断，在当前DOM之外构建一个字树，之后再将其拷贝回文档
- 将原始元素拷贝到一个脱离文档流的节点中，修改副本后再替换原始元素

##### 其他

- 减少布局信息的获取次数
- 如果有动画元素，使动画元素使用绝对定位脱离文档流
- 避免在大量元素上使用:hover伪类操作

#### 4. 事件委托

当页面中大量元素需要添加事件监听器时，如果为每个元素都添加事件监听器则会造成页面负担加重、执行之间增加或占用更多的内存。

此时可以使用事件委托来解决，事件逐层冒泡并能被父级元素捕获，使用事件代理，只需要给外层元素绑定一个事件监听器，就可以处理其子元素上触发的所有事件。

标准的DOM事件都会经历以下三个阶段：

- 捕获
- 到达目标
- 冒泡

使用事件委托除了提高性能之外，如果新添加了一个子元素，则不用为这个新添加的子元素绑定事件监听器。如果不使用事件委托，则需要为新添加的元素绑定事件监听器。

事件委托需要做以下工作：

- 访问事件对象，并判断事件源
- 取消文档中的事件冒泡(可选，e.stopPropagation())
- 阻止事件默认行为(可选，e.preventDefault())


#### 小结

- 最小化DOM访问次数，尽可能在JavaScript端处理
- 如果需要多次访问某个DOM节点，使用局部变量存储它们的引用
- 要注意HTML集合，因为它们与文档保持实时连接
- 使用速度更快的API，比如querySelector
- 最小化重绘和重排，批量修改时，先将元素脱离文档流，修改完后再放回文档流
- 动画元素使用绝对定位
- 使用事件委托减少事件处理器的数量
